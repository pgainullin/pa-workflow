"""
Test to verify that PDF attachments generated by print_to_pdf are properly
passed to callbacks with both file_id and content fields populated.

This addresses the issue: "PDF generated by print-to-pdf never passed as 
attachment to callback"
"""
import asyncio
import base64
from unittest.mock import AsyncMock, MagicMock, patch

import pytest


@pytest.mark.asyncio
async def test_collect_attachments_includes_content_and_file_id():
    """Test that _collect_attachments downloads files and includes both content and file_id."""
    with patch("llama_index.llms.google_genai.GoogleGenAI") as mock_llm, \
         patch("google.genai.Client") as mock_genai, \
         patch("basic.email_workflow.download_file_from_llamacloud") as mock_download:
        
        from basic.email_workflow import EmailWorkflow
        
        # Mock the file download
        test_pdf_bytes = b"Mock PDF content here"
        mock_download.return_value = test_pdf_bytes
        
        workflow = EmailWorkflow()
        
        # Simulate results from print_to_pdf tool
        results = [
            {
                "step": 1,
                "tool": "print_to_pdf",
                "description": "Generate PDF document",
                "success": True,
                "file_id": "test-pdf-file-id-123",
            }
        ]
        
        # Collect attachments
        attachments = await workflow._collect_attachments(results)
        
        # Verify download was called
        mock_download.assert_called_once_with("test-pdf-file-id-123")
        
        # Verify attachment was created correctly
        assert len(attachments) == 1
        attachment = attachments[0]
        
        # Check all fields
        assert attachment.name == "output_step_1.pdf"
        assert attachment.type == "application/pdf"
        assert attachment.file_id == "test-pdf-file-id-123"
        
        # CRITICAL: Verify content is also present
        assert attachment.content is not None, "content field should be populated"
        
        # Verify content is valid base64
        decoded = base64.b64decode(attachment.content)
        assert decoded == test_pdf_bytes
        
        print("✅ Test passed: Attachment has both file_id and content")


@pytest.mark.asyncio
async def test_collect_attachments_handles_download_failure_gracefully():
    """Test that if download fails, attachment is still created with file_id only."""
    with patch("llama_index.llms.google_genai.GoogleGenAI") as mock_llm, \
         patch("google.genai.Client") as mock_genai, \
         patch("basic.email_workflow.download_file_from_llamacloud") as mock_download:
        
        from basic.email_workflow import EmailWorkflow
        
        # Mock the download to fail
        mock_download.side_effect = Exception("Download failed")
        
        workflow = EmailWorkflow()
        
        results = [
            {
                "step": 1,
                "tool": "print_to_pdf",
                "success": True,
                "file_id": "test-file-id",
            }
        ]
        
        # Should not raise exception
        attachments = await workflow._collect_attachments(results)
        
        # Should still create attachment with file_id
        assert len(attachments) == 1
        assert attachments[0].file_id == "test-file-id"
        # But content should be None due to download failure
        assert attachments[0].content is None
        
        print("✅ Test passed: Graceful handling of download failure")


@pytest.mark.asyncio
async def test_callback_includes_both_fields():
    """Test end-to-end that callback JSON includes both file_id and content."""
    with patch("llama_index.llms.google_genai.GoogleGenAI") as mock_llm, \
         patch("google.genai.Client") as mock_genai, \
         patch("basic.email_workflow.download_file_from_llamacloud") as mock_download, \
         patch("httpx.AsyncClient") as mock_client_class:
        
        from basic.email_workflow import EmailWorkflow
        from basic.models import SendEmailRequest
        
        # Mock the file download
        test_pdf_bytes = b"Test PDF content"
        mock_download.return_value = test_pdf_bytes
        
        # Mock httpx client
        mock_client = AsyncMock()
        mock_response = MagicMock()
        mock_response.raise_for_status = MagicMock()
        mock_client.post = AsyncMock(return_value=mock_response)
        mock_client.__aenter__ = AsyncMock(return_value=mock_client)
        mock_client.__aexit__ = AsyncMock()
        mock_client_class.return_value = mock_client
        
        workflow = EmailWorkflow()
        
        # Create results with print_to_pdf output
        results = [
            {
                "step": 1,
                "tool": "print_to_pdf",
                "description": "Generate PDF",
                "success": True,
                "file_id": "test-file-id",
            }
        ]
        
        # Collect attachments
        attachments = await workflow._collect_attachments(results)
        
        # Create email request (simulating what send_results does)
        email_request = SendEmailRequest(
            to_email="user@example.com",
            subject="Test",
            text="Your PDF is attached",
            attachments=attachments
        )
        
        # Send callback
        await workflow._send_callback_email(
            callback_url="http://localhost:8000/callback",
            auth_token="test-token",
            email_request=email_request
        )
        
        # Verify the POST was called
        assert mock_client.post.called
        call_kwargs = mock_client.post.call_args[1]
        callback_json = call_kwargs["json"]
        
        # Verify attachments in callback JSON
        assert "attachments" in callback_json
        assert len(callback_json["attachments"]) == 1
        
        attachment_data = callback_json["attachments"][0]
        
        # CRITICAL: Both fields should be present in callback
        assert "file_id" in attachment_data, "file_id should be in callback JSON"
        assert attachment_data["file_id"] == "test-file-id"
        
        assert "content" in attachment_data, "content should be in callback JSON"
        assert attachment_data["content"] is not None, "content should not be None"
        
        # Verify content is valid base64 of the PDF
        decoded = base64.b64decode(attachment_data["content"])
        assert decoded == test_pdf_bytes
        
        print("✅ Test passed: Callback includes both file_id and content")
        print(f"   file_id: {attachment_data['file_id']}")
        print(f"   content length: {len(attachment_data['content'])} chars (base64)")


@pytest.mark.asyncio
async def test_multiple_pdf_attachments():
    """Test that multiple PDFs from different steps are all handled correctly."""
    with patch("llama_index.llms.google_genai.GoogleGenAI") as mock_llm, \
         patch("google.genai.Client") as mock_genai, \
         patch("basic.email_workflow.download_file_from_llamacloud") as mock_download:
        
        from basic.email_workflow import EmailWorkflow
        
        # Mock downloads to return different content
        def download_side_effect(file_id):
            if file_id == "file-1":
                return b"First PDF"
            elif file_id == "file-2":
                return b"Second PDF"
            else:
                raise ValueError(f"Unexpected file_id: {file_id}")
        
        mock_download.side_effect = download_side_effect
        
        workflow = EmailWorkflow()
        
        results = [
            {
                "step": 1,
                "tool": "print_to_pdf",
                "success": True,
                "file_id": "file-1",
            },
            {
                "step": 2,
                "tool": "parse",
                "success": True,
                "parsed_text": "Some text",
            },
            {
                "step": 3,
                "tool": "print_to_pdf",
                "success": True,
                "file_id": "file-2",
            },
        ]
        
        attachments = await workflow._collect_attachments(results)
        
        # Should have 2 PDF attachments
        assert len(attachments) == 2
        
        # Check first PDF
        assert attachments[0].file_id == "file-1"
        assert attachments[0].content is not None
        assert base64.b64decode(attachments[0].content) == b"First PDF"
        
        # Check second PDF
        assert attachments[1].file_id == "file-2"
        assert attachments[1].content is not None
        assert base64.b64decode(attachments[1].content) == b"Second PDF"
        
        print("✅ Test passed: Multiple PDFs handled correctly")
